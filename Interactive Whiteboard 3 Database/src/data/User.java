package data;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.NoSuchElementException;
import java.util.Scanner;

import managers.userdata.UserListManager;
import managers.userdata.UserNotFoundException;

import util.CommonMethods;

/**
 * Stores all the information of a single user. Each user has a unique username that identifies him/her
 */
final public class User
{	
	/**
	 * separates one input from another input when files are being scanned through
	 */
	final public static String DELIMITER = " ";	//The separates one input from another input when files are being read to load user data
	
	/**
	 * the default display name of a user. the display name is the name other users will see associated with
	 * this user. it is not necessarily the same as the username and is not unique. For example, someone could
	 * have the username "bsmith" and have display name "Bob Smith" because usernames might not look as nice
	 * as full names.<p>
	 * 
	 * when a user is created, their display name defaults to this display name.
	 */
	final public static String DEFAULT_DISPLAY_NAME = "No_Name";
	
	/**
	 * the default name change code of a user. the name change code is the code users will use to modify their
	 * name. since it could get annoying is someone is "John" on moment and then wants to impersonate "Mary" so
	 * he changes his name to "Mary," we are simply requiring a name change code every time a user wants
	 * to change his/her display name. the name change code is generated by the whiteboard server (not this
	 * server - this server is the database server) to prevent people from misusing their display name.<p>
	 * 
	 * when a user is created, the user may not like his/her default display name, so the default name change
	 * code exists so the user gets a free name change at the start. all name change codes can only be used
	 * once.
	 */
	final public static String DEFAULT_NAME_CHANGE_CODE = "DEFAULT";
	
	/**
	 * when a name change code has been used, the name change code of this user is replaced with this code
	 * signifying that this user no longer has a name change code and can no longer change his/her name.
	 */
	final public static String NO_NAME_CHANGE_CODE = "---";

	/**
	 * maximum number of lines of private messaging history this database server is willing to store for each user.
	 */
	final public static int MAXIMUM_LINES_OF_PM_HISTORY = 1000;	//This is the maximum lines of PM History this database will store for any user
	
	/**
	 * the username of this user. it cannot be changed.
	 */
	final private String m_username;
	
	/**
	 * the password of this user. the password is required for the user to login. 
	 */
	private String m_password;
	
	/**
	 * the display name of the user. a user is assigned a default display name when s/he register. then
	 * s/he can modify it.
	 * 
	 * @see 		#DEFAULT_DISPLAY_NAME
	 * @see			#DEFAULT_NAME_CHANGE_CODE
	 */
	private String m_displayName = DEFAULT_DISPLAY_NAME;
	
	/**
	 * the name change code for the user, if one exists. Each user will only have one name change code stored
	 * because it could get annoying if people "stockpiled" name change codes to impersonate others.
	 * 
	 * @see			#DEFAULT_DISPLAY_NAME
	 * @see			#DEFAULT_NAME_CHANGE_CODE
	 */
	private String m_nameChangeCode = DEFAULT_NAME_CHANGE_CODE;
	
	/**
	 * the friends list of the user
	 */
	private ArrayList<UserData> m_friendsList = new ArrayList<UserData>();
	
	/**
	 * the pests list of the user of the people the user would like to ignore.
	 */
	private ArrayList<UserData> m_pestsList = new ArrayList<UserData>();
	
	/**
	 * the private messaging history of the user
	 */
	private ArrayList<PrivateMessage> m_pmHistory = new ArrayList<PrivateMessage>();
	
	/**
	 * Constructor. Called when a user registers and defaults everything.
	 * 
	 * @param username			a String, the username with which the person registered.
	 * @param password			a String, the password with which the person registered.
	 * @throws IOException		if a file containing the user data could not be created
	 */
	public User(String username, String password) throws IOException
	{
		//Store the registration data
		this.m_username = username;
		this.m_password = password;
		//Everything else will be defiAned later by the server
		save();
	}
	
	/**
	 * Constructor. Called when loading data of an existing user.
	 * 
	 * @param file							a File, where all the user data is located on the system
	 * @throws IOException					if the file could not be found
	 * @throws NoSuchElementException		if a piece of data is expected, but none is found (file formatted incorrectly)
	 * @throws NumberFormatException		if a number is expected, but no number is found (file formatted incorrectly)
	 */
	public User(File file) throws IOException, NoSuchElementException, NumberFormatException
	{
		//open the file and prepare to read it
		FileReader userDataFileReader = new FileReader(file);
		BufferedReader userDataBufferedReader = new BufferedReader(userDataFileReader);
		Scanner s = new Scanner(userDataBufferedReader);
		//the first line is the username
		String username = s.nextLine();
			this.m_username = username;
		//the second line is the password
		String password = s.nextLine();
			this.m_password = password;
		//the third line is the display name
		String displayName = s.nextLine();
			this.m_displayName = displayName;
		//the fourth line is the name change code
		String nameChangeCode = s.nextLine();
			this.m_nameChangeCode = nameChangeCode;
		//the fifth line is the number, F, of friends the user has
		int numberOfFriends = Integer.parseInt(s.nextLine());
		//then there is a list of F friends. Each friend is identified with a username
		for (int numberOfFriendsRead = 0; numberOfFriendsRead < numberOfFriends; numberOfFriendsRead++)
		{
			String friendInformation = s.nextLine();
			Scanner scanFriendInformation = new Scanner(friendInformation);
			String friendUsername = scanFriendInformation.next();
			UserData friend = new UserData(friendUsername);
			this.m_friendsList.add(friend);
			scanFriendInformation.close();
		}
		//then there is the number, P, of pests the user has
		int numberOfPests = Integer.parseInt(s.nextLine());
		//then there is a list of P pests. Each pest is identified with a username
		for (int numberOfPestsRead = 0; numberOfPestsRead < numberOfPests; numberOfPestsRead++)
		{
			String pestInformation = s.nextLine();
			Scanner scanPestInformation = new Scanner(pestInformation);
			String pestUsername = scanPestInformation.next();
			UserData pest = new UserData(pestUsername);
			this.m_pestsList.add(pest);
			scanPestInformation.close();
		}
		//then there is the number, M, of lines of private message history the user has
		int linesOfPrivateMessagingHistory = Integer.parseInt(s.nextLine());
		//then there is a list of M lines of private messaging history. Each message is identified with 
		//the username of the other person involved in the conversation, the username of the sender of the message and the message contents
		for (int numberOfLinesRead = 0; numberOfLinesRead < linesOfPrivateMessagingHistory; numberOfLinesRead++)
		{
			String messageInformation = s.nextLine();
			Scanner scanMessageInformation = new Scanner(messageInformation);
			String senderUsername = scanMessageInformation.next();
			String recipientUsername = scanMessageInformation.next();
			String message = scanMessageInformation.next();
			boolean isMessageRead = scanMessageInformation.nextBoolean();
			PrivateMessage privateMessage = new PrivateMessage(senderUsername, recipientUsername, message, isMessageRead);
			this.m_pmHistory.add(privateMessage);
			scanMessageInformation.close();
		}
		userDataFileReader.close();
		userDataBufferedReader.close();
		s.close();
	}
	
	/**
	 * this prefix identifies a file that it is a user data file
	 */
	final public static String USER_FILENAME_PREFIX = "user_";
	/**
	 * saves user data.
	 * 
	 * @throws IOException		if the user data file could not be found or written to.
	 */
	final private void save() throws IOException
	{
		//determine the filename, which will be prefixed with user_ and then the username of the user
		String filename = USER_FILENAME_PREFIX + this.m_username;
		//prepare to write to the file
		PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(filename)));
		//the first line is the username
		out.println(this.m_username);
		//the second line is the password
		out.println(this.m_password);
		//the third line is the display name
		out.println(this.m_displayName);
		//the fourth line is the name change code
		out.println(this.m_nameChangeCode);
		//the fifth line is the number of friends
		int numberOfFriends = this.m_friendsList.size();
		out.println(numberOfFriends);
		//then print all friends
		for (int numberOfFriendsPrinted = 0; numberOfFriendsPrinted < numberOfFriends; numberOfFriendsPrinted++)
		{
			int indexOfFriend = numberOfFriendsPrinted;
			//each line will contain a friend's username
			String lineToPrint = this.m_friendsList.get(indexOfFriend).getUsername();
			out.println(lineToPrint);
		}
		//then print the number of pests
		int numberOfPests = this.m_pestsList.size();
		out.println(numberOfPests);
		//then print all pests
		for (int numberOfPestsPrinted = 0; numberOfPestsPrinted < numberOfPests; numberOfPestsPrinted++)
		{
			int indexOfPest = numberOfPestsPrinted;
			//each line will contain a pest's username
			String lineToPrint = this.m_pestsList.get(indexOfPest).getUsername();
			out.println(lineToPrint);
		}
		//then print the number of private messages
		int numberOfPrivateMessages = this.m_pmHistory.size();
		out.println(numberOfPrivateMessages);
		//then print all private messages
		for (int numberOfMessagesPrinted = 0; numberOfMessagesPrinted < numberOfPrivateMessages; numberOfMessagesPrinted++)
		{
			int indexOfMessage = numberOfMessagesPrinted;
			//each line will contain the other user's username and the contents of the message
			PrivateMessage aLineOfPmHistory = this.m_pmHistory.get(indexOfMessage);
			String senderUsername = aLineOfPmHistory.getSender();
			String recipientUsername = aLineOfPmHistory.getRecipient();
			String message = aLineOfPmHistory.getMessageContents();
			boolean isMessageRead = aLineOfPmHistory.isMessageRead();
			String lineToPrint = senderUsername + DELIMITER + recipientUsername + DELIMITER + message + DELIMITER + isMessageRead;
			out.println(lineToPrint);
		}
		//then close and we are done
		out.close();
	}
	
	/**
	 * Attempts to save user data and handles exceptions that might occur.
	 */
	final private void attemptSave()
	{
		try
		{
			save();
		} catch (IOException e)
		{
			CommonMethods.logInternalMessage("UNEXPECTED ERROR: Could not write to file \"" + USER_FILENAME_PREFIX + this.m_username + "\"");
		}
	}
	
	/**
	 * @return		the username of this user
	 * @see			#m_username
	 */
	final public String getUsername()
	{
		return this.m_username;
	}
	
	/**
	 * @return		the password of this user
	 * @see			#m_password
	 */
	final public String getPassword()
	{
		return this.m_password;
	}
	
	/**
	 * changes the password of the current user.
	 * Assumes:<br>
	 * 1) the new password meets all password requirements.
	 * 
	 * @param currentPassword				a String, the current password of the user, which is required to change the password
	 * @param newPassword					a String, the new password for the user
	 * @throws AccessDeniedException		if the current password provided was incorrect.
	 */
	final public void setPassword(String currentPassword, String newPassword) throws AccessDeniedException
	{
		assertPasswordIsCorrect(currentPassword);
		this.m_password = newPassword;
		attemptSave();
	}
	
	/**
	 * @param password						a String, the current password of the user
	 * @return								the display name of the user
	 * @throws AccessDeniedException		if the current password provided was incorrect
	 */
	final public String getDisplayName(String password) throws AccessDeniedException
	{
		assertPasswordIsCorrect(password);
		return this.m_displayName;
	}
	
	/**
	 * changes the display name of this user
	 * Assumes:<br>
	 * 1) new display name meets all naming requirements
	 * 
	 * @param password						a String, the current password of the user
	 * @param nameChangeCode				a String, the name change code of the user
	 * @param newDisplayName				a String, the desired new username
	 * @throws AccessDeniedException		if the password and/or the name change code provided are/is incorrect
	 */
	final public void setDisplayName(String password, String nameChangeCode, String newDisplayName) throws AccessDeniedException
	{
		assertPasswordIsCorrect(password);
		assertNameChangeCodeIsCorrect(nameChangeCode);
		this.m_displayName = newDisplayName;
		this.m_nameChangeCode = NO_NAME_CHANGE_CODE;
		try 
		{
			UserListManager.changeDisplayNameOfUser(this.getUsername(), newDisplayName);
		} catch (UserNotFoundException e)
		{
			//ignore the user exists - or else how could we have reached this block?
		}
		attemptSave();
	}
	
	/**
	 * @param password						a String, the current password of this user
	 * @return								the name change code of this user
	 * @throws AccessDeniedException		if the current password provided was incorrect
	 */
	final public String getNameChangeCode(String password) throws AccessDeniedException
	{
		assertPasswordIsCorrect(password);
		return this.m_nameChangeCode;
	}
	
	/**
	 * changes the new name change code to a new sequence of characters and numbers.
	 * Assumes:<br>
	 * 1) the new name change code was generated by <code> getRandomNameChangeCode()</code>
	 * 
	 * @param password						the current password of the user
	 * @param newNameChangeCode				the new name change code for this user
	 * @throws AccessDeniedException		if the current password provided was incorrect
	 * @see									#getRandomNameChangeCode()
	 */
	//this assumes:
	//1) the given name change code was generated by the method getRandomNameChangeCode()
	final public void setNameChangeCode(String password, String newNameChangeCode) throws AccessDeniedException
	{
		assertPasswordIsCorrect(password);
		this.m_nameChangeCode = newNameChangeCode;
		attemptSave();
	}
	
	/**
	 * These are the characters that can be in a name change code. We exclude 0 and O because they look alike
	 * and may be confusing
	 */
	final private static char[] NAME_CHANGE_CODE_CHARACTERS = {'1', '2', '3', '4', '5', '6', '7', '8', '9', 
																'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 
																'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 
																'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
	final private static int NAME_CHANGE_CODE_LENGTH = 25;
	/**
	 * generates a random sequence of 25 characters/numbers that defines a name change code
	 * 
	 * @return		a randomly generated name change code
	 * @see			#setNameChangeCode(String, String)
	 * @see			#NAME_CHANGE_CODE_CHARACTERS
	 */
	final public static String getRandomNameChangeCode()
	{
		String aNameChangeCode = "";
		//choose 25 characters
		for (int numberOfCharactersChosen = 0; numberOfCharactersChosen < NAME_CHANGE_CODE_LENGTH; numberOfCharactersChosen++)
		{
			//randomly pick a character for each of the 25 characters that must be part of the name change code
			int characterIndex = (int)(Math.random() * NAME_CHANGE_CODE_CHARACTERS.length);
			aNameChangeCode += NAME_CHANGE_CODE_CHARACTERS[characterIndex];
		}
		return aNameChangeCode;
	}
	

	/**
	 * adds a friend to this user's friends list.
	 * 
	 * @param password						a String, the current password of the user
	 * @param friendUsername						a String, the username of the friend to add
	 * @throws AccessDeniedException		if the current password provided was incorrect
	 */
	final public void addFriend(String password, String friendUsername) throws AccessDeniedException
	{
		assertPasswordIsCorrect(password);
		//make sure the friend is not already on this list
		for (int currentFriendsIndex = 0; currentFriendsIndex < this.m_friendsList.size(); currentFriendsIndex++)
		{
			if (this.m_friendsList.get(currentFriendsIndex).getUsername().equals(friendUsername))
			{
				return;
			}
		}
		UserData newFriend = new UserData(friendUsername);
		this.m_friendsList.add(newFriend);
		attemptSave();
	}
	
	/**
	 * @param password						a String, the current password of the user
	 * @return								the number of friends this user has on his/her friends list
	 * @throws AccessDeniedException		if the current password provided was incorrect
	 * @see									#m_friendsList
	 */
	final public int getNumberOfFriends(String password) throws AccessDeniedException
	{
		assertPasswordIsCorrect(password);
		return this.m_friendsList.size();
	}
	
	/**
	 * gets the username of a friend at a specified index
	 * Assumes:<br>
	 * 1) the given index is not out of range<br>
	 * 
	 * @param password						a String, the current password of the user
	 * @param indexOfFriend					an integer, the location of the friend in the friends list data
	 * @return								the username of the friend at the given location
	 * @throws AccessDeniedException		if the current password provided was incorrect
	 * @see									#m_friendsList
	 */
	final public String getFriendsListUsernameAt(String password, int indexOfFriend) throws AccessDeniedException
	{
		assertPasswordIsCorrect(password);
		return this.m_friendsList.get(indexOfFriend).getUsername();
	}
	
	/**
	 * determines if a given username is the username of a friend on this user's friends list. does not 
	 * require a password because this is used by the whiteboard server to determine who should know
	 * that this user logged on/off if this user does log on or off
	 * 
	 * @param username						a String, the username to check for on this user's friends list
	 * @return								true if the given username is on this user's friends list. false if not.
	 * @throws AccessDeniedException		if the current password provided was incorrect
	 * @see									#m_friendsList
	 */
	final public boolean isUsernameOnFriendsList(String username)
	{
		//Go through the friends list and see if there are any friends with the given username
		for (int friendsChecked = 0; friendsChecked < this.m_friendsList.size(); friendsChecked++)
		{
			int friendIndex = friendsChecked;
			if (this.m_friendsList.get(friendIndex).getUsername().equals(username))
			{
				return true;
			}
		}
		return false;
	}
	
	/**
	 * removes a friend from this user's friends list.
	 * Assumes:<br>
	 * 1) the given username is on the friends list.
	 * 
	 * @param password						a String, the current password of the user
	 * @param usernameOfFriend				a String, the username of the friend to remove
	 * @throws AccessDeniedException		if the current password provided was incorrect
	 * @see									#m_friendsList
	 */
	final public void removeFriend(String password, String usernameOfFriend) throws AccessDeniedException
	{
		assertPasswordIsCorrect(password);
		//go through every friend and check for friend with the given username
		for (int friendsChecked = 0; friendsChecked < this.m_friendsList.size(); friendsChecked++)
		{
			int friendIndex = friendsChecked;
			if (this.m_friendsList.get(friendIndex).getUsername().equals(usernameOfFriend))
			{
				//remove the friend
				this.m_friendsList.remove(friendIndex);
				//and we are done
				return;
			}
		}
		attemptSave();
	}
	
	/**
	 * adds a username to this user's pests list.
	 * Assumes:<br>
	 * 1) the user exists<br>
	 * 
	 * @param password						a String, the current password of the user				
	 * @param username						a String, the username of the pest to add
	 * @throws AccessDeniedException		if the current password provided was incorrect
	 * @see									#m_pestsList
	 */
	final public void addPest(String password, String username) throws AccessDeniedException
	{
		assertPasswordIsCorrect(password);
		//make sure the user is not already on the pests list
		for (int currentPestsIndex = 0; currentPestsIndex < this.m_pestsList.size(); currentPestsIndex++)
		{
			if (this.m_pestsList.get(currentPestsIndex).getUsername().equals(username))
			{
				return;
			}
		}
		UserData newPest = new UserData(username);
		this.m_pestsList.add(newPest);
		attemptSave();
	}
	
	/**
	 * @param password						a String, the current password of the user
	 * @return								the number of pests on this user's pest list
	 * @throws AccessDeniedException		if the current password provided was incorrect
	 * @see									#m_pestsList
	 */
	final public int getNumberOfPests(String password) throws AccessDeniedException
	{
		assertPasswordIsCorrect(password);
		return this.m_pestsList.size();
	}
	
	/**
	 * gets the username of a pest on the pests list given an index.
	 * Assumes:<br>
	 * 1) the index is not out of range
	 * 
	 * @param password						a String, the current password of the user
	 * @param indexOfPest					an integer, the location of the pest in the pests list
	 * @return								the username of the pest determined by the given index
	 * @throws AccessDeniedException		if the current password provided was incorrect
	 * @see									#m_pestsList
	 */
	final public String getPestsListUsernameAt(String password, int indexOfPest) throws AccessDeniedException
	{
		assertPasswordIsCorrect(password);
		return this.m_pestsList.get(indexOfPest).getUsername();
	}
	
	/**
	 * determines if a given username is on this user's pests list. not password protected because
	 * people that are not this user may request to see if this person is online or not. the server
	 * needs to access this user's pests list to determine if the person making the request should be
	 * allowed to know.
	 * 
	 * @param username						a String, the username to look for on the pests list
	 * @return								true if the username is on this person's pests list. false if not
	 * @throws AccessDeniedException		if the current password provided was incorrect.
	 * @see									#m_pestsList
	 */
	final public boolean isUsernameOnPestsList(String username)
	{
		//go through each entry in the pests list and see if it has a matching username
		for (int pestsChecked = 0; pestsChecked < this.m_pestsList.size(); pestsChecked++)
		{
			int pestIndex = pestsChecked;
			if (this.m_pestsList.get(pestIndex).getUsername().equals(username))
			{
				return true;
			}
		}
		return false;
	}
	
	/**
	 * removes a pest from this user's pests list. 
	 * Assumes:<br>
	 * 1) the given username is of a pest on this user's pests list
	 * 
	 * @param password						a String, the current password of the user
	 * @param username						a String, the username of the pest to remove
	 * @throws AccessDeniedException		if the current password provided was incorrect
	 * @see									#m_pestsList
	 */
	final public void removePest(String password, String username) throws AccessDeniedException
	{
		assertPasswordIsCorrect(password);
		//go through each entry in the pests list and check for a matching username
		for (int pestsChecked = 0; pestsChecked < this.m_pestsList.size(); pestsChecked++)
		{
			int pestIndex = pestsChecked;
			if (this.m_pestsList.get(pestIndex).getUsername().equals(username))
			{
				//remove the pest
				this.m_pestsList.remove(pestIndex);
				//we are done - there can only be one copy of each username in the list at any given time
				return;
			}
		}
		attemptSave();
	}
	
	
	/**
	 * for every private message, we assume the sender has read the private message when it was sent
	 */
	final private static boolean DEFAULT_IS_MESSAGE_READ_FOR_SENDER = true;
	/**
	 * for every private message, we assume the reicpient has not read the private message when it was sent
	 */
	final private static boolean DEFAULT_IS_MESSAGE_READ_FOR_RECIPIENT = false;
	/**
	 * adds a line of private message history to the list of private messages sent and received by this user.
	 * assumes:<br>
	 * 1) the sender of the message exists<br>
	 * 2) the recipient of the message exists<br>
	 * 3) the password is not null if this user is the sender
	 * 4) the password is null if this user is the recipient
	 * 
	 * @param sender						a String, the username of the sender of the message
	 * @param password						a String, the current password of the user
	 * @param recipient						a String, the username of the recipient of the message
	 * @param message						a String, the contents of the message
	 * @param isMessageRead					a boolean, if the message has been read by the recipient yet
	 * @throws AccessDeniedException		if the current password provided was incorrect
	 * @see									#m_pmHistory
	 */
	final public void addToPmHistory(String sender, String password, String recipient, String message) throws AccessDeniedException
	{
		if (sender.equals(this.getUsername()) && password != null)
		{
			assertPasswordIsCorrect(password);
			PrivateMessage newMessage = new PrivateMessage(sender, recipient, message, DEFAULT_IS_MESSAGE_READ_FOR_SENDER);
			this.m_pmHistory.add(newMessage);
			enforceMaxLinesOfPmHistory();
			attemptSave();
		} else if (recipient.equals(this.getUsername()))
		{
			PrivateMessage newMessage = new PrivateMessage(sender, recipient, message, DEFAULT_IS_MESSAGE_READ_FOR_RECIPIENT);
			this.m_pmHistory.add(newMessage);
			enforceMaxLinesOfPmHistory();
			attemptSave();
		}
	}
	
	/**
	 * ensures that there the maximum lines of private message history stored for this user has not exceeded the maximum.
	 * Assumes:<br>
	 * 1) the maximum lines of PM history is positive
	 * 2) the maximum lines of PM history is not greater than <code>Integer.MAX_VALUE</code>
	 * 
	 * @see			#MAXIMUM_LINES_OF_PM_HISTORY
	 */
	final public void enforceMaxLinesOfPmHistory()
	{
		int indexOfOldestMessage = 0;
		//keep removing the oldest message until the number of lines of pm history
		//becomes less than the maximum lines that can be stored
		while (this.m_pmHistory.size() > MAXIMUM_LINES_OF_PM_HISTORY)
		{
			this.m_pmHistory.remove(indexOfOldestMessage);
		}
	}
	
	/**
	 * determines the number of lines of pm history stored
	 * 
	 * @param password						a String, the current password of this user
	 * @return								the number of lines of pm history currently stored
	 * @throws AccessDeniedException		if the current password provided was incorrect
	 * @see									#m_pmHistory
	 */
	final public int getNumberOfLinesOfPmHistory(String password) throws AccessDeniedException
	{
		assertPasswordIsCorrect(password);
		return this.m_pmHistory.size();
	}
	
	/**
	 * determines the username of the recipient of a specific line of pm history in the pm history data.
	 * 
	 * @param password						a String, the current password of this user
	 * @param indexOfPm						an integer, where in the pm history data the line of pm history is
	 * @return								the username of the recipient of the line of pm history specified by the index
	 * @throws AccessDeniedException		if the current password provided was incorrect
	 * @see									#m_pmHistory
	 */
	final public String getPmHistoryRecipientAt(String password, int indexOfPm) throws AccessDeniedException
	{
		assertPasswordIsCorrect(password);
		return this.m_pmHistory.get(indexOfPm).getRecipient();
	}

	/**
	 * determines the message that was sent given a specific line of pm history in the pm history archives.
	 * 
	 * @param password						a String, the current password of the user
	 * @param indexOfPm						an integer, where in the pm history archives to look for the line of pm history
	 * @return								the message that was sent
	 * @throws AccessDeniedException		if the current password provided was incorrect
	 * @see									#m_pmHistory
	 */
	final public String getPmHistoryMessageAt(String password, int indexOfPm) throws AccessDeniedException
	{
		assertPasswordIsCorrect(password);
		return this.m_pmHistory.get(indexOfPm).getMessageContents();
	}
	
	/**
	 * determines the sender of given a specific line of pm history in the pm history arhives.
	 * 
	 * @param password						a String, the current password of the user
	 * @param indexOfPm						an integer, where in the archives to look for the line of pm history
	 * @return								the username of the sender
	 * @throws AccessDeniedException		if the current password provided was incorrect
	 * @see									#m_pmHistory
	 */
	final public String getPmHistorySenderAt(String password, int indexOfPm) throws AccessDeniedException
	{
		assertPasswordIsCorrect(password);
		return this.m_pmHistory.get(indexOfPm).getSender();
	}
	
	/**
	 * determines the recipient of a line of pm history read the message yet, given a line of pm history from the archives
	 * 
	 * @param password						a String, the current password of the user
	 * @param indexOfPm						an integer, where in the archives to look for the line of pm history
	 * @return								true if the message was read. false if the message was not read.
	 * @throws AccessDeniedException		if the current password provided was incorrect.
	 */
	final public boolean isPmHistoryReadAt(String password, int indexOfPm) throws AccessDeniedException
	{
		assertPasswordIsCorrect(password);
		return this.m_pmHistory.get(indexOfPm).isMessageRead();
	}
	
	/**
	 * sets all all the messages in a conversation with another person as read.
	 *  
	 * @param password						a String, the current password of the user
	 * @param otherPersonInvolved			a String, the username of the other person in the conversation
	 * @throws AccessDeniedException		if the current password provided was incorrect
	 * @see									#m_pmHistory
	 */
	final public void setPrivateMessagesRead(String password, String otherPersonInvolved) throws AccessDeniedException
	{
		assertPasswordIsCorrect(password);
		for (int pmIndex = 0; pmIndex < this.m_pmHistory.size(); pmIndex++)
		{
			PrivateMessage aMessage = this.m_pmHistory.get(pmIndex);
			if (aMessage.getRecipient().equals(otherPersonInvolved) || aMessage.getSender().equals(otherPersonInvolved))
			{
				aMessage.setMessageRead();
			}
		}
	}
	
	/**
	 * makes sure an inputed password for this user is correct. if it is not correct, an <code>AccessDeniedException</code>
	 * is generated.
	 * 
	 * @param password						an inputed current password of this user
	 * @throws AccessDeniedException		if the current password of this user provided is incorrect
	 * @see									AccessDeniedException
	 * @see									#m_password
	 */
	final private void assertPasswordIsCorrect(String password) throws AccessDeniedException
	{
		if(!password.equals(this.m_password))
		{
			throw generateExceptionForBadPassword(this.m_username, password);
		}
	}
	
	/**
	 * makes sure an inputed name change code for this user is correct. if it is not correct, an <code>AccessDeniedException</code>
	 * is generated.
	 * 
	 * @param nameChangeCode				an inputed name change code of this user
	 * @throws AccessDeniedException		if the inputed name change code of this user provided is incorrect
	 * @see									AccessDeniedException
	 * @see									#m_nameChangeCode
	 */
	final private void assertNameChangeCodeIsCorrect(String nameChangeCode) throws AccessDeniedException
	{
		if (!nameChangeCode.equals(this.m_nameChangeCode) || nameChangeCode.equals(NO_NAME_CHANGE_CODE))
		{
			throw generateExceptionForBadNameChangeCode(this.m_username, nameChangeCode);
		}
	}
	
	/**
	 * creates an <code>AcessDeniedException</code> with a message saying that a bad password was provided
	 * 
	 * @param username		a String, the username of this user
	 * @param password		a String, the bad password provided
	 * @return				an exception with information about why access was denied
	 */
	final private static AccessDeniedException generateExceptionForBadPassword(String username, String password)
	{
		String message = "One or more of the following fields are incorrect:\n"
							+ "Username: " + username + "\n"
							+ "Password: " + password + "\n";
		return new AccessDeniedException(message, AccessDeniedException.BAD_PASSWORD_ERROR);
	}
	
	/**
	 * creates an <code>AccessDeniedException</code> with a message saying that a bad name change code was provided
	 * 
	 * @param username				a String, the username of this user
	 * @param nameChangeCode		a String, the bad name change code provided
	 * @return						an exception with information about why access was denied
	 */
	final private static AccessDeniedException generateExceptionForBadNameChangeCode(String username, String nameChangeCode)
	{
		String message = "One or more of the following fields are incorrect:\n"
							+ "Username: " + username + "\n"
							+ "Name Change Code: " + nameChangeCode + "\n";
		return new AccessDeniedException(message, AccessDeniedException.BAD_NAME_CHANGE_CODE_ERROR);
	}
	
	/**
	 * Stores a username, which is all the information a client will need to store about other users
	 */
	final private class UserData
	{
		final private String m_userDataUsername;
		
		/**
		 * Constructor
		 * @param username		the username of the other user
		 */
		public UserData(String username)
		{
			this.m_userDataUsername = username;
		}
		
		/**
		 * @return		the username the user this represents
		 */
		final public String getUsername()
		{
			return this.m_userDataUsername;
		}
	}
	
	/**
	 * Stores information about private messages
	 */
	final private class PrivateMessage
	{
		
		/**
		 * the username of the sender sending the message
		 */
		final private String m_sender;
		
		/**
		 * the username of the person receiving the message
		 */
		final private String m_recipient;
		
		/**
		 * the contents of the message
		 */
		final private String m_message;
		
		/**
		 * if the message has been read yet (by the recipient - of course the sender read the message s/he sent)
		 */
		private boolean m_isMessageRead;
		
		/**
		 * Constructor.
		 * 
		 * @param sender				a String, the username of the sender
		 * @param recipient				a String, the username of the recipient
		 * @param message				a String, the contents of the message 
		 * @param isMessageRead			a boolean, if the recipient read the message yet
		 */
		public PrivateMessage(String sender, String recipient, String message, boolean isMessageRead)
		{
			this.m_sender = sender;
			this.m_recipient = recipient;
			this.m_message = message;
			this.m_isMessageRead = isMessageRead;
		}
		
		
		/**
		 * @return		the username of the sender
		 */
		final public String getSender()
		{
			return this.m_sender;
		}
		
		/**
		 * @return		the username of the recipient
		 */
		final public String getRecipient()
		{
			return this.m_recipient;
		}
		
		/**
		 * @return		the message contents
		 */
		final public String getMessageContents()
		{
			return this.m_message;
		}
		
		/**
		 * @return		if the recipient read the message yet
		 */
		final public boolean isMessageRead()
		{
			return this.m_isMessageRead;
		}
		
		/**
		 * sets this message as read
		 */
		final public void setMessageRead()
		{
			this.m_isMessageRead = true;
		}
	}
	
	//DEBUG
	/*
	final public static void main(String[] args) throws IOException
	{
		File file = new File("DEBUG/data/user_testing");
		User user = new User(file);
		System.out.println(user.getUsername());
		System.out.println(user.getPassword());
		System.out.println(user.getDisplayName());
		System.out.println(user.getNameChangeCode());
		System.out.println(user.getNumberOfFriends());
		for (int i = 0; i < user.getNumberOfFriends(); i++)
		{
			System.out.println(user.getFriendsListUsernameAt(i));
		}
		System.out.println(user.getNumberOfPests());
		for (int i = 0; i < user.getNumberOfPests(); i++)
		{
			System.out.println(user.getPestsListUsernameAt(i));
		}
		System.out.println(user.getNumberOfLinesOfPmHistory());
		for (int i = 0; i < user.getNumberOfLinesOfPmHistory(); i++)
		{
			System.out.println(user.getPmHistoryUsernameAt(i) + " " + user.getPmHistoryMessageAt(i));
		}
		user.save();
		System.out.println("Test finished");
	}*/ 
	//END DEBUG
}
